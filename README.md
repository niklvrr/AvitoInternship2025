# Сервис назначения ревьюеров для Pull Request'ов

Микросервис для автоматического назначения ревьюеров на Pull Request'ы из команды автора, управления командами и участниками, а также переназначения ревьюверов. Взаимодействие происходит через HTTP API.

## Содержание

- [Выполненный функционал](#выполненный-функционал)
- [Архитектура](#архитектура)
- [Стек технологий](#стек-технологий)
- [Конфигурация](#конфигурация)
- [Запуск проекта](#запуск-проекта)
- [Тестирование](#тестирование)
- [Дополнительный функционал](#дополнительный-функционал)
- [Примечания](#примечания)

## Выполненный функционал

### Основной функционал

Реализованы все эндпоинты согласно спецификации OpenAPI:

**Управление командами:**
- `POST /team/add` - создание команды с участниками (создает/обновляет пользователей)
- `GET /team/get` - получение команды с участниками

**Управление пользователями:**
- `POST /users/setIsActive` - установка флага активности пользователя
- `GET /users/getReview` - получение списка PR, где пользователь назначен ревьювером

**Управление Pull Request'ами:**
- `POST /pullRequest/create` - создание PR с автоматическим назначением до 2 активных ревьюверов из команды автора
- `POST /pullRequest/merge` - пометка PR как MERGED (идемпотентная операция)
- `POST /pullRequest/reassign` - переназначение конкретного ревьювера на другого из его команды

**Мониторинг:**
- `GET /health` - проверка здоровья сервиса
- `GET /metrics` - метрики Prometheus

## Архитектура

Проект следует принципам Clean Architecture и разделен на следующие слои:

**Transport Layer (internal/transport):**
- HTTP handlers для обработки запросов
- Middleware: Recovery, Logging, RequestID, Timeout, Metrics
- Роутинг на базе chi router
- DTO для запросов и ответов

**Use Case Layer (internal/usecase/service):**
- Бизнес-логика приложения
- Обработка ошибок домена
- Координация работы репозиториев

**Infrastructure Layer (internal/infrastructure):**
- Репозитории для работы с базой данных
- Модели данных (DTO, Result)
- Подключение к базе данных и миграции

**Domain Layer (internal/domain):**
- Доменные модели (User, Team, PR)

**Config Layer (internal/config):**
- Загрузка конфигурации из переменных окружения

**Logger (pkg/logger):**
- Структурированное логирование на базе zap

## Стек технологий

- **Язык:** Go 1.25
- **База данных:** PostgreSQL 16
- **HTTP роутер:** chi/v5
- **Логирование:** zap (go.uber.org/zap)
- **Миграции:** golang-migrate/migrate/v4
- **База данных драйвер:** pgx/v5
- **Метрики:** prometheus/client_golang
- **Тестирование:** testify, testcontainers-go
- **Линтер:** golangci-lint

## Конфигурация

### Переменные окружения

Приложение использует переменные окружения для конфигурации. Все переменные имеют значения по умолчанию и могут быть переопределены через `.env` файл или переменные окружения системы.

**Переменные приложения:**
- `APP_ENV` - окружение приложения (dev/prod). По умолчанию: `dev`
- `APP_PORT` - порт для HTTP сервера. По умолчанию: `8080`

**Переменные базы данных:**
- `DB_HOST` - хост базы данных. По умолчанию: `localhost` (для docker-compose: `db`)
- `DB_PORT` - порт базы данных. По умолчанию: `5432`
- `DB_NAME` - имя базы данных. По умолчанию: `postgres`
- `DB_USER` - пользователь базы данных. По умолчанию: `postgres`
- `DB_PASSWORD` - пароль базы данных. По умолчанию: `postgres`
- `DB_URL` - полный URL подключения к базе данных (опционально, формируется автоматически из отдельных параметров)

### Пример .env файла

```
APP_ENV=dev
APP_PORT=8080
DB_HOST=localhost
DB_PORT=5432
DB_NAME=postgres
DB_USER=postgres
DB_PASSWORD=postgres
```

## Запуск проекта

### Требования

- Docker и Docker Compose
- Go 1.25+ (для локальной разработки)

### Запуск через Docker Compose

Сервис и его зависимости поднимаются командой `docker-compose up`:

```bash
docker-compose up
```

При выполнении этой команды:
1. Запускается контейнер PostgreSQL
2. Собирается и запускается контейнер приложения
3. Автоматически применяются миграции базы данных
4. Сервис становится доступен на порту 8080

Для запуска в фоновом режиме:

```bash
docker-compose up -d
```

Для остановки:

```bash
docker-compose down
```

### Локальная разработка

Для локальной разработки можно использовать Makefile (подробнее см. раздел [Makefile команды](#makefile-команды)):

1. Запустить базу данных:
```bash
make docker-up
```

2. Применить миграции:
```bash
make migrate-up
```

3. Запустить приложение:
```bash
make run
```

## Тестирование

### Unit тесты

Запуск всех unit тестов:

```bash
make test
```

Или напрямую:

```bash
go test -v ./...
```

Запуск тестов с покрытием:

```bash
make test-coverage
```

Отчет о покрытии будет сохранен в файл `coverage.html`.

**Покрытие кода:**
- Сервисный слой: 75.9%
- Транспортный слой: 86.1%

### E2E тесты

E2E тесты используют testcontainers для запуска изолированной PostgreSQL базы данных в Docker контейнере.

Запуск E2E тестов:

```bash
make test-e2e
```

Или напрямую:

```bash
go test -v -timeout 10m ./tests/e2e/...
```

E2E тесты покрывают:
- Все эндпоинты согласно спецификации OpenAPI
- Успешные сценарии
- Все описанные в спецификации ошибки
- Граничные случаи

### Нагрузочное тестирование

Нагрузочные тесты находятся в пакете `tests/load` и выполняются с тегом `load`.

**Требования:**
- Сервер должен быть запущен и доступен на `http://localhost:8080`

Запуск нагрузочных тестов:

```bash
go test -tags load -v ./tests/load/...
```

Или для конкретного теста:

```bash
go test -tags load -v -run TestLoad_CreatePR ./tests/load/...
go test -tags load -v -run TestLoad_MergePR ./tests/load/...
go test -tags load -v -run TestLoad_GetStatistics ./tests/load/...
```

**Параметры нагрузочного тестирования:**
- Целевой RPS: 5 запросов в секунду
- Длительность: 30 секунд
- Максимальная задержка P99: 300 мс
- Минимальный процент успешности: 99.9%
- Допустимое отклонение RPS: ±10%

### Линтер

Запуск линтера:

```bash
make lint
```

Или напрямую:

```bash
golangci-lint run
```

Конфигурация линтера находится в файле `.golangci.yml` в корне проекта.

## Makefile команды

Подробное описание всех доступных команд:

- `make help` - показать справку по командам
- `make build` - собрать бинарный файл
- `make run` - собрать и запустить приложение
- `make test` - запустить unit тесты
- `make test-coverage` - запустить тесты с покрытием
- `make test-e2e` - запустить E2E тесты
- `make lint` - запустить линтер
- `make fmt` - отформатировать код
- `make clean` - удалить скомпилированные файлы
- `make docker-up` - запустить контейнеры
- `make docker-down` - остановить контейнеры
- `make migrate-up` - применить миграции
- `make migrate-down` - откатить миграции

## Дополнительный функционал

### Эндпоинт статистики `/stats`

Реализован дополнительный эндпоинт для получения статистики по назначениям ревьюверов.

**Путь:** `GET /stats`

**Описание:** Возвращает статистику по количеству назначений ревьюверов по пользователям и по Pull Request'ам.

**Запрос:**
- Метод: `GET`
- Путь: `/stats`
- Заголовки: не требуются
- Тело запроса: отсутствует

**Ответ:**

Успешный ответ (200 OK):

```json
{
  "users": [
    {
      "user_id": "u1",
      "username": "Alice",
      "assignments": 5
    },
    {
      "user_id": "u2",
      "username": "Bob",
      "assignments": 3
    }
  ],
  "prs": [
    {
      "pr_id": "pr-1001",
      "pr_name": "Add search",
      "reviewers_count": 2
    },
    {
      "pr_id": "pr-1002",
      "pr_name": "Fix bug",
      "reviewers_count": 1
    }
  ]
}
```

**Структура ответа:**

- `users` (массив объектов) - статистика по пользователям:
  - `user_id` (string) - идентификатор пользователя
  - `username` (string) - имя пользователя
  - `assignments` (integer) - количество назначений пользователя ревьювером
- `prs` (массив объектов) - статистика по Pull Request'ам:
  - `pr_id` (string) - идентификатор PR
  - `pr_name` (string) - название PR
  - `reviewers_count` (integer) - количество назначенных ревьюверов

**Ошибки:**

Эндпоинт может возвращать стандартные HTTP ошибки:
- `500 Internal Server Error` - внутренняя ошибка сервера при выполнении запроса

**Реализация:**

Эндпоинт выполняет два SQL запроса:
1. Агрегация количества назначений по пользователям из таблицы `pr_reviewers` с группировкой по `user_id`
2. Агрегация количества ревьюверов по PR из таблицы `pr_reviewers` с группировкой по `pr_id`

Результаты сортируются по убыванию количества назначений и по имени для удобства анализа.

### Нагрузочное тестирование

Реализовано нагрузочное тестирование для проверки соответствия требованиям SLI.

**Реализованные тесты:**

1. **TestLoad_CreatePR** - нагрузочное тестирование создания Pull Request'ов
   - Тестирует эндпоинт `POST /pullRequest/create`
   - Проверяет производительность при создании множества PR

2. **TestLoad_MergePR** - нагрузочное тестирование слияния Pull Request'ов
   - Тестирует эндпоинт `POST /pullRequest/merge`
   - Проверяет идемпотентность операции merge под нагрузкой

3. **TestLoad_GetStatistics** - нагрузочное тестирование получения статистики
   - Тестирует эндпоинт `GET /stats`
   - Проверяет производительность агрегационных запросов

**Метрики:**

Каждый тест собирает и валидирует следующие метрики:
- Общее количество запросов
- Количество успешных запросов
- Количество запросов с ошибками
- Процент успешности (должен быть >= 99.9%)
- Фактический RPS (должен быть в диапазоне 4.5-5.5 для целевого RPS=5)
- Задержки: средняя, P50, P95, P99, P99.9
- P99 задержка должна быть <= 300 мс

**Результаты:**

Тесты автоматически валидируют соответствие требованиям SLI:
- SLI времени ответа: P99 <= 300 мс
- SLI успешности: >= 99.9%

При несоответствии требованиям тесты завершаются с ошибкой и выводят детальную информацию о метриках.

**Запуск:**

```bash
go test -tags load -v ./tests/load/...
```

Перед запуском необходимо убедиться, что сервер запущен и доступен на `http://localhost:8080`.

### E2E тестирование

Реализовано комплексное E2E тестирование с использованием testcontainers для изоляции тестовой среды.

**Технологии:**
- testcontainers-go для запуска PostgreSQL в Docker
- httptest для симуляции HTTP сервера
- testify для ассертов

**Структура тестов:**

Тесты разделены по сущностям в отдельные файлы:
- `tests/e2e/team_e2e_test.go` - тесты для управления командами
- `tests/e2e/user_e2e_test.go` - тесты для управления пользователями
- `tests/e2e/pr_e2e_test.go` - тесты для управления Pull Request'ами
- `tests/e2e/stats_e2e_test.go` - тесты для эндпоинта статистики
- `tests/e2e/common_test.go` - общая настройка тестовой среды

**Покрытие:**

E2E тесты покрывают все эндпоинты согласно спецификации OpenAPI:

**Команды:**
- Создание команды (успех, дубликат)
- Получение команды (успех, не найдена, отсутствует параметр)

**Пользователи:**
- Установка активности (успех, не найден)
- Получение списка PR пользователя (успех, пустой список, не найден, отсутствует параметр)

**Pull Request'ы:**
- Создание PR (успех, нулевое количество ревьюверов, дубликат, автор не найден)
- Слияние PR (успех, идемпотентность, не найден)
- Переназначение ревьювера (успех, PR смержен, ревьювер не назначен, нет кандидатов, не найден)

**Статистика:**
- Получение статистики (успех, пустая база данных)

**Особенности:**

- Тесты строго соответствуют спецификации OpenAPI
- Проверяются все описанные в спецификации ошибки
- Тесты не зависят от реализации, проверяют только ожидаемое поведение согласно спецификации
- Каждый тест изолирован и использует уникальные данные
- Автоматическое применение миграций перед запуском тестов

**Запуск:**

```bash
make test-e2e
```

Или напрямую:

```bash
go test -v -timeout 10m ./tests/e2e/...
```

### Конфигурация линтера

Настроен golangci-lint с расширенной конфигурацией для обеспечения качества кода.

**Файл конфигурации:** `.golangci.yml`

**Включенные линтеры:**

**Основные линтеры (обязательные):**
- `errcheck` - проверка обработки ошибок
- `gosimple` - упрощение кода
- `govet` - статический анализ кода
- `ineffassign` - обнаружение неэффективных присваиваний
- `staticcheck` - статический анализ
- `unused` - обнаружение неиспользуемого кода
- `typecheck` - проверка типов

**Стиль кода:**
- `gofmt` - форматирование кода
- `goimports` - управление импортами
- `misspell` - проверка орфографии
- `revive` - альтернативный линтер стиля
- `gocritic` - расширенная проверка кода
- `gosec` - проверка безопасности

**Сложность кода:**
- `gocyclo` - проверка цикломатической сложности (минимум 15)
- `gocognit` - проверка когнитивной сложности (минимум 15)
- `funlen` - проверка длины функций (максимум 100 строк, 50 statements)

**Дополнительные проверки:**
- `exportloopref` - обнаружение экспорта ссылок на переменные цикла
- `prealloc` - предварительное выделение памяти
- `unconvert` - обнаружение ненужных преобразований типов
- `unparam` - обнаружение неиспользуемых параметров
- `varnamelen` - проверка длины имен переменных
- `whitespace` - проверка пробелов
- `nakedret` - обнаружение голых return
- `noctx` - проверка передачи context
- `rowserrcheck` - проверка обработки ошибок rows
- `sqlclosecheck` - проверка закрытия SQL ресурсов
- `errname` - проверка именования ошибок
- `errorlint` - проверка работы с ошибками
- `gochecknoinits` - запрет init функций
- `gochecknoglobals` - запрет глобальных переменных
- `godot` - проверка комментариев
- `godox` - проверка TODO комментариев
- `goerr113` - проверка работы с ошибками
- `gomnd` - проверка магических чисел
- `goprintffuncname` - проверка имен функций printf
- `lll` - проверка длины строк (максимум 120 символов)
- `maligned` - проверка выравнивания структур
- `nolintlint` - проверка корректности nolint директив
- `stylecheck` - проверка стиля кода

**Настройки:**

- Таймаут выполнения: 5 минут
- Проверка тестов: включена
- Исключены директории: `vendor`, `migrations`
- Исключены файлы: `*.pb.go`, `*.gen.go`
- Для тестовых файлов отключены некоторые проверки сложности

**Запуск:**

```bash
make lint
```

Или напрямую:

```bash
golangci-lint run
```

**Установка:**

Если golangci-lint не установлен:

```bash
go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
```

## Примечания

### Опечатка в openapi.yml

В файле `openapi.yml` обнаружена опечатка в примере запроса для эндпоинта `/pullRequest/reassign`. В схеме запроса указано поле `old_user_id` (строка 344), однако в примере (строка 347) используется `old_reviewer_id`.

В реализации приложения за основу было взято название поля из схемы, то есть `old_user_id`. Файл `openapi.yml` не изменялся, опечатка сохранена как есть.

### Структура проекта

```
.
├── cmd/                    # Точка входа приложения
│   └── main.go
├── internal/               # Внутренний код приложения
│   ├── config/            # Конфигурация
│   ├── domain/            # Доменные модели
│   ├── infrastructure/    # Инфраструктурный слой
│   │   ├── db/           # Подключение к БД и миграции
│   │   ├── models/      # DTO и Result модели
│   │   └── repository/  # Репозитории
│   ├── transport/        # Транспортный слой
│   │   ├── dto/         # DTO для запросов/ответов
│   │   ├── handler/    # HTTP handlers
│   │   └── middleware/ # Middleware
│   └── usecase/         # Слой бизнес-логики
│       └── service/    # Сервисы
├── pkg/                  # Переиспользуемые пакеты
│   └── logger/          # Логирование
├── migrations/          # SQL миграции
├── tests/               # Тесты
│   ├── e2e/            # E2E тесты
│   └── load/           # Нагрузочные тесты
├── .golangci.yml        # Конфигурация линтера
├── docker-compose.yml   # Docker Compose конфигурация
├── Dockerfile          # Docker образ приложения
├── Makefile            # Команды для разработки
├── openapi.yml         # OpenAPI спецификация
└── README.md          # Документация

```

### База данных

Приложение использует PostgreSQL с следующими таблицами:
- `users` - пользователи
- `teams` - команды
- `team_members` - связь пользователей с командами
- `prs` - Pull Request'ы
- `pr_reviewers` - связь ревьюверов с PR

Миграции автоматически применяются при запуске приложения через `db.NewDatabase`.

### Логирование

Приложение использует структурированное логирование через zap. Уровень логирования зависит от переменной окружения `APP_ENV`:
- `dev` - DEBUG уровень
- `prod` - INFO уровень

Логи включают:
- Request ID для трейсинга запросов
- Структурированные поля для удобного поиска
- Метрики производительности запросов

